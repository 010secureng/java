/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coreos.monitoring.models;

import java.util.Objects;
import java.util.Arrays;
import com.coreos.monitoring.models.V1PodMonitorSpecPodMetricsEndpointsInnerOauth2;
import com.coreos.monitoring.models.V1PrometheusSpecRemoteReadInnerAuthorization;
import com.coreos.monitoring.models.V1PrometheusSpecRemoteReadInnerBasicAuth;
import com.coreos.monitoring.models.V1PrometheusSpecRemoteReadInnerTlsConfig;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * RemoteReadSpec defines the configuration for Prometheus to read back samples from a remote endpoint.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-01T07:02:10.169254Z[Etc/UTC]")
public class V1PrometheusSpecRemoteReadInner {
  public static final String SERIALIZED_NAME_AUTHORIZATION = "authorization";
  @SerializedName(SERIALIZED_NAME_AUTHORIZATION)
  private V1PrometheusSpecRemoteReadInnerAuthorization authorization;

  public static final String SERIALIZED_NAME_BASIC_AUTH = "basicAuth";
  @SerializedName(SERIALIZED_NAME_BASIC_AUTH)
  private V1PrometheusSpecRemoteReadInnerBasicAuth basicAuth;

  public static final String SERIALIZED_NAME_BEARER_TOKEN = "bearerToken";
  @SerializedName(SERIALIZED_NAME_BEARER_TOKEN)
  private String bearerToken;

  public static final String SERIALIZED_NAME_BEARER_TOKEN_FILE = "bearerTokenFile";
  @SerializedName(SERIALIZED_NAME_BEARER_TOKEN_FILE)
  private String bearerTokenFile;

  public static final String SERIALIZED_NAME_FILTER_EXTERNAL_LABELS = "filterExternalLabels";
  @SerializedName(SERIALIZED_NAME_FILTER_EXTERNAL_LABELS)
  private Boolean filterExternalLabels;

  public static final String SERIALIZED_NAME_HEADERS = "headers";
  @SerializedName(SERIALIZED_NAME_HEADERS)
  private Map<String, String> headers = new HashMap<>();

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OAUTH2 = "oauth2";
  @SerializedName(SERIALIZED_NAME_OAUTH2)
  private V1PodMonitorSpecPodMetricsEndpointsInnerOauth2 oauth2;

  public static final String SERIALIZED_NAME_PROXY_URL = "proxyUrl";
  @SerializedName(SERIALIZED_NAME_PROXY_URL)
  private String proxyUrl;

  public static final String SERIALIZED_NAME_READ_RECENT = "readRecent";
  @SerializedName(SERIALIZED_NAME_READ_RECENT)
  private Boolean readRecent;

  public static final String SERIALIZED_NAME_REMOTE_TIMEOUT = "remoteTimeout";
  @SerializedName(SERIALIZED_NAME_REMOTE_TIMEOUT)
  private String remoteTimeout;

  public static final String SERIALIZED_NAME_REQUIRED_MATCHERS = "requiredMatchers";
  @SerializedName(SERIALIZED_NAME_REQUIRED_MATCHERS)
  private Map<String, String> requiredMatchers = new HashMap<>();

  public static final String SERIALIZED_NAME_TLS_CONFIG = "tlsConfig";
  @SerializedName(SERIALIZED_NAME_TLS_CONFIG)
  private V1PrometheusSpecRemoteReadInnerTlsConfig tlsConfig;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  private String url;

  public V1PrometheusSpecRemoteReadInner() {
  }

  public V1PrometheusSpecRemoteReadInner authorization(V1PrometheusSpecRemoteReadInnerAuthorization authorization) {
    
    this.authorization = authorization;
    return this;
  }

   /**
   * Get authorization
   * @return authorization
  **/
  @jakarta.annotation.Nullable
  public V1PrometheusSpecRemoteReadInnerAuthorization getAuthorization() {
    return authorization;
  }


  public void setAuthorization(V1PrometheusSpecRemoteReadInnerAuthorization authorization) {
    this.authorization = authorization;
  }


  public V1PrometheusSpecRemoteReadInner basicAuth(V1PrometheusSpecRemoteReadInnerBasicAuth basicAuth) {
    
    this.basicAuth = basicAuth;
    return this;
  }

   /**
   * Get basicAuth
   * @return basicAuth
  **/
  @jakarta.annotation.Nullable
  public V1PrometheusSpecRemoteReadInnerBasicAuth getBasicAuth() {
    return basicAuth;
  }


  public void setBasicAuth(V1PrometheusSpecRemoteReadInnerBasicAuth basicAuth) {
    this.basicAuth = basicAuth;
  }


  public V1PrometheusSpecRemoteReadInner bearerToken(String bearerToken) {
    
    this.bearerToken = bearerToken;
    return this;
  }

   /**
   * Bearer token for remote read.
   * @return bearerToken
  **/
  @jakarta.annotation.Nullable
  public String getBearerToken() {
    return bearerToken;
  }


  public void setBearerToken(String bearerToken) {
    this.bearerToken = bearerToken;
  }


  public V1PrometheusSpecRemoteReadInner bearerTokenFile(String bearerTokenFile) {
    
    this.bearerTokenFile = bearerTokenFile;
    return this;
  }

   /**
   * File to read bearer token for remote read.
   * @return bearerTokenFile
  **/
  @jakarta.annotation.Nullable
  public String getBearerTokenFile() {
    return bearerTokenFile;
  }


  public void setBearerTokenFile(String bearerTokenFile) {
    this.bearerTokenFile = bearerTokenFile;
  }


  public V1PrometheusSpecRemoteReadInner filterExternalLabels(Boolean filterExternalLabels) {
    
    this.filterExternalLabels = filterExternalLabels;
    return this;
  }

   /**
   * Whether to use the external labels as selectors for the remote read endpoint. Requires Prometheus v2.34.0 and above.
   * @return filterExternalLabels
  **/
  @jakarta.annotation.Nullable
  public Boolean getFilterExternalLabels() {
    return filterExternalLabels;
  }


  public void setFilterExternalLabels(Boolean filterExternalLabels) {
    this.filterExternalLabels = filterExternalLabels;
  }


  public V1PrometheusSpecRemoteReadInner headers(Map<String, String> headers) {
    
    this.headers = headers;
    return this;
  }

  public V1PrometheusSpecRemoteReadInner putHeadersItem(String key, String headersItem) {
    if (this.headers == null) {
      this.headers = new HashMap<>();
    }
    this.headers.put(key, headersItem);
    return this;
  }

   /**
   * Custom HTTP headers to be sent along with each remote read request. Be aware that headers that are set by Prometheus itself can&#39;t be overwritten. Only valid in Prometheus versions 2.26.0 and newer.
   * @return headers
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getHeaders() {
    return headers;
  }


  public void setHeaders(Map<String, String> headers) {
    this.headers = headers;
  }


  public V1PrometheusSpecRemoteReadInner name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name of the remote read queue, it must be unique if specified. The name is used in metrics and logging in order to differentiate read configurations.  Only valid in Prometheus versions 2.15.0 and newer.
   * @return name
  **/
  @jakarta.annotation.Nullable
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1PrometheusSpecRemoteReadInner oauth2(V1PodMonitorSpecPodMetricsEndpointsInnerOauth2 oauth2) {
    
    this.oauth2 = oauth2;
    return this;
  }

   /**
   * Get oauth2
   * @return oauth2
  **/
  @jakarta.annotation.Nullable
  public V1PodMonitorSpecPodMetricsEndpointsInnerOauth2 getOauth2() {
    return oauth2;
  }


  public void setOauth2(V1PodMonitorSpecPodMetricsEndpointsInnerOauth2 oauth2) {
    this.oauth2 = oauth2;
  }


  public V1PrometheusSpecRemoteReadInner proxyUrl(String proxyUrl) {
    
    this.proxyUrl = proxyUrl;
    return this;
  }

   /**
   * Optional ProxyURL.
   * @return proxyUrl
  **/
  @jakarta.annotation.Nullable
  public String getProxyUrl() {
    return proxyUrl;
  }


  public void setProxyUrl(String proxyUrl) {
    this.proxyUrl = proxyUrl;
  }


  public V1PrometheusSpecRemoteReadInner readRecent(Boolean readRecent) {
    
    this.readRecent = readRecent;
    return this;
  }

   /**
   * Whether reads should be made for queries for time ranges that the local storage should have complete data for.
   * @return readRecent
  **/
  @jakarta.annotation.Nullable
  public Boolean getReadRecent() {
    return readRecent;
  }


  public void setReadRecent(Boolean readRecent) {
    this.readRecent = readRecent;
  }


  public V1PrometheusSpecRemoteReadInner remoteTimeout(String remoteTimeout) {
    
    this.remoteTimeout = remoteTimeout;
    return this;
  }

   /**
   * Timeout for requests to the remote read endpoint.
   * @return remoteTimeout
  **/
  @jakarta.annotation.Nullable
  public String getRemoteTimeout() {
    return remoteTimeout;
  }


  public void setRemoteTimeout(String remoteTimeout) {
    this.remoteTimeout = remoteTimeout;
  }


  public V1PrometheusSpecRemoteReadInner requiredMatchers(Map<String, String> requiredMatchers) {
    
    this.requiredMatchers = requiredMatchers;
    return this;
  }

  public V1PrometheusSpecRemoteReadInner putRequiredMatchersItem(String key, String requiredMatchersItem) {
    if (this.requiredMatchers == null) {
      this.requiredMatchers = new HashMap<>();
    }
    this.requiredMatchers.put(key, requiredMatchersItem);
    return this;
  }

   /**
   * An optional list of equality matchers which have to be present in a selector to query the remote read endpoint.
   * @return requiredMatchers
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getRequiredMatchers() {
    return requiredMatchers;
  }


  public void setRequiredMatchers(Map<String, String> requiredMatchers) {
    this.requiredMatchers = requiredMatchers;
  }


  public V1PrometheusSpecRemoteReadInner tlsConfig(V1PrometheusSpecRemoteReadInnerTlsConfig tlsConfig) {
    
    this.tlsConfig = tlsConfig;
    return this;
  }

   /**
   * Get tlsConfig
   * @return tlsConfig
  **/
  @jakarta.annotation.Nullable
  public V1PrometheusSpecRemoteReadInnerTlsConfig getTlsConfig() {
    return tlsConfig;
  }


  public void setTlsConfig(V1PrometheusSpecRemoteReadInnerTlsConfig tlsConfig) {
    this.tlsConfig = tlsConfig;
  }


  public V1PrometheusSpecRemoteReadInner url(String url) {
    
    this.url = url;
    return this;
  }

   /**
   * The URL of the endpoint to query from.
   * @return url
  **/
  @jakarta.annotation.Nonnull
  public String getUrl() {
    return url;
  }


  public void setUrl(String url) {
    this.url = url;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1PrometheusSpecRemoteReadInner v1PrometheusSpecRemoteReadInner = (V1PrometheusSpecRemoteReadInner) o;
    return Objects.equals(this.authorization, v1PrometheusSpecRemoteReadInner.authorization) &&
        Objects.equals(this.basicAuth, v1PrometheusSpecRemoteReadInner.basicAuth) &&
        Objects.equals(this.bearerToken, v1PrometheusSpecRemoteReadInner.bearerToken) &&
        Objects.equals(this.bearerTokenFile, v1PrometheusSpecRemoteReadInner.bearerTokenFile) &&
        Objects.equals(this.filterExternalLabels, v1PrometheusSpecRemoteReadInner.filterExternalLabels) &&
        Objects.equals(this.headers, v1PrometheusSpecRemoteReadInner.headers) &&
        Objects.equals(this.name, v1PrometheusSpecRemoteReadInner.name) &&
        Objects.equals(this.oauth2, v1PrometheusSpecRemoteReadInner.oauth2) &&
        Objects.equals(this.proxyUrl, v1PrometheusSpecRemoteReadInner.proxyUrl) &&
        Objects.equals(this.readRecent, v1PrometheusSpecRemoteReadInner.readRecent) &&
        Objects.equals(this.remoteTimeout, v1PrometheusSpecRemoteReadInner.remoteTimeout) &&
        Objects.equals(this.requiredMatchers, v1PrometheusSpecRemoteReadInner.requiredMatchers) &&
        Objects.equals(this.tlsConfig, v1PrometheusSpecRemoteReadInner.tlsConfig) &&
        Objects.equals(this.url, v1PrometheusSpecRemoteReadInner.url);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authorization, basicAuth, bearerToken, bearerTokenFile, filterExternalLabels, headers, name, oauth2, proxyUrl, readRecent, remoteTimeout, requiredMatchers, tlsConfig, url);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1PrometheusSpecRemoteReadInner {\n");
    sb.append("    authorization: ").append(toIndentedString(authorization)).append("\n");
    sb.append("    basicAuth: ").append(toIndentedString(basicAuth)).append("\n");
    sb.append("    bearerToken: ").append(toIndentedString(bearerToken)).append("\n");
    sb.append("    bearerTokenFile: ").append(toIndentedString(bearerTokenFile)).append("\n");
    sb.append("    filterExternalLabels: ").append(toIndentedString(filterExternalLabels)).append("\n");
    sb.append("    headers: ").append(toIndentedString(headers)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    oauth2: ").append(toIndentedString(oauth2)).append("\n");
    sb.append("    proxyUrl: ").append(toIndentedString(proxyUrl)).append("\n");
    sb.append("    readRecent: ").append(toIndentedString(readRecent)).append("\n");
    sb.append("    remoteTimeout: ").append(toIndentedString(remoteTimeout)).append("\n");
    sb.append("    requiredMatchers: ").append(toIndentedString(requiredMatchers)).append("\n");
    sb.append("    tlsConfig: ").append(toIndentedString(tlsConfig)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("authorization");
    openapiFields.add("basicAuth");
    openapiFields.add("bearerToken");
    openapiFields.add("bearerTokenFile");
    openapiFields.add("filterExternalLabels");
    openapiFields.add("headers");
    openapiFields.add("name");
    openapiFields.add("oauth2");
    openapiFields.add("proxyUrl");
    openapiFields.add("readRecent");
    openapiFields.add("remoteTimeout");
    openapiFields.add("requiredMatchers");
    openapiFields.add("tlsConfig");
    openapiFields.add("url");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("url");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1PrometheusSpecRemoteReadInner
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1PrometheusSpecRemoteReadInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1PrometheusSpecRemoteReadInner is not found in the empty JSON string", V1PrometheusSpecRemoteReadInner.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1PrometheusSpecRemoteReadInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1PrometheusSpecRemoteReadInner` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : V1PrometheusSpecRemoteReadInner.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // validate the optional field `authorization`
      if (jsonObj.get("authorization") != null && !jsonObj.get("authorization").isJsonNull()) {
        V1PrometheusSpecRemoteReadInnerAuthorization.validateJsonObject(jsonObj.getAsJsonObject("authorization"));
      }
      // validate the optional field `basicAuth`
      if (jsonObj.get("basicAuth") != null && !jsonObj.get("basicAuth").isJsonNull()) {
        V1PrometheusSpecRemoteReadInnerBasicAuth.validateJsonObject(jsonObj.getAsJsonObject("basicAuth"));
      }
      if ((jsonObj.get("bearerToken") != null && !jsonObj.get("bearerToken").isJsonNull()) && !jsonObj.get("bearerToken").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bearerToken` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bearerToken").toString()));
      }
      if ((jsonObj.get("bearerTokenFile") != null && !jsonObj.get("bearerTokenFile").isJsonNull()) && !jsonObj.get("bearerTokenFile").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `bearerTokenFile` to be a primitive type in the JSON string but got `%s`", jsonObj.get("bearerTokenFile").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `oauth2`
      if (jsonObj.get("oauth2") != null && !jsonObj.get("oauth2").isJsonNull()) {
        V1PodMonitorSpecPodMetricsEndpointsInnerOauth2.validateJsonObject(jsonObj.getAsJsonObject("oauth2"));
      }
      if ((jsonObj.get("proxyUrl") != null && !jsonObj.get("proxyUrl").isJsonNull()) && !jsonObj.get("proxyUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `proxyUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("proxyUrl").toString()));
      }
      if ((jsonObj.get("remoteTimeout") != null && !jsonObj.get("remoteTimeout").isJsonNull()) && !jsonObj.get("remoteTimeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `remoteTimeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("remoteTimeout").toString()));
      }
      // validate the optional field `tlsConfig`
      if (jsonObj.get("tlsConfig") != null && !jsonObj.get("tlsConfig").isJsonNull()) {
        V1PrometheusSpecRemoteReadInnerTlsConfig.validateJsonObject(jsonObj.getAsJsonObject("tlsConfig"));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1PrometheusSpecRemoteReadInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1PrometheusSpecRemoteReadInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1PrometheusSpecRemoteReadInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1PrometheusSpecRemoteReadInner.class));

       return (TypeAdapter<T>) new TypeAdapter<V1PrometheusSpecRemoteReadInner>() {
           @Override
           public void write(JsonWriter out, V1PrometheusSpecRemoteReadInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1PrometheusSpecRemoteReadInner read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1PrometheusSpecRemoteReadInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1PrometheusSpecRemoteReadInner
  * @throws IOException if the JSON string is invalid with respect to V1PrometheusSpecRemoteReadInner
  */
  public static V1PrometheusSpecRemoteReadInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1PrometheusSpecRemoteReadInner.class);
  }

 /**
  * Convert an instance of V1PrometheusSpecRemoteReadInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

