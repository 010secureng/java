/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.coreos.monitoring.models;

import java.util.Objects;
import java.util.Arrays;
import com.coreos.monitoring.models.V1AlertmanagerSpecAffinity;
import com.coreos.monitoring.models.V1AlertmanagerSpecAlertmanagerConfigMatcherStrategy;
import com.coreos.monitoring.models.V1AlertmanagerSpecAlertmanagerConfigNamespaceSelector;
import com.coreos.monitoring.models.V1AlertmanagerSpecAlertmanagerConfigSelector;
import com.coreos.monitoring.models.V1AlertmanagerSpecAlertmanagerConfiguration;
import com.coreos.monitoring.models.V1AlertmanagerSpecContainersInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecContainersInnerVolumeMountsInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecHostAliasesInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecImagePullSecretsInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecPodMetadata;
import com.coreos.monitoring.models.V1AlertmanagerSpecResources;
import com.coreos.monitoring.models.V1AlertmanagerSpecSecurityContext;
import com.coreos.monitoring.models.V1AlertmanagerSpecStorage;
import com.coreos.monitoring.models.V1AlertmanagerSpecTolerationsInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecTopologySpreadConstraintsInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecVolumesInner;
import com.coreos.monitoring.models.V1AlertmanagerSpecWeb;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * Specification of the desired behavior of the Alertmanager cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-01T07:02:10.169254Z[Etc/UTC]")
public class V1AlertmanagerSpec {
  public static final String SERIALIZED_NAME_ADDITIONAL_PEERS = "additionalPeers";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_PEERS)
  private List<String> additionalPeers;

  public static final String SERIALIZED_NAME_AFFINITY = "affinity";
  @SerializedName(SERIALIZED_NAME_AFFINITY)
  private V1AlertmanagerSpecAffinity affinity;

  public static final String SERIALIZED_NAME_ALERTMANAGER_CONFIG_MATCHER_STRATEGY = "alertmanagerConfigMatcherStrategy";
  @SerializedName(SERIALIZED_NAME_ALERTMANAGER_CONFIG_MATCHER_STRATEGY)
  private V1AlertmanagerSpecAlertmanagerConfigMatcherStrategy alertmanagerConfigMatcherStrategy;

  public static final String SERIALIZED_NAME_ALERTMANAGER_CONFIG_NAMESPACE_SELECTOR = "alertmanagerConfigNamespaceSelector";
  @SerializedName(SERIALIZED_NAME_ALERTMANAGER_CONFIG_NAMESPACE_SELECTOR)
  private V1AlertmanagerSpecAlertmanagerConfigNamespaceSelector alertmanagerConfigNamespaceSelector;

  public static final String SERIALIZED_NAME_ALERTMANAGER_CONFIG_SELECTOR = "alertmanagerConfigSelector";
  @SerializedName(SERIALIZED_NAME_ALERTMANAGER_CONFIG_SELECTOR)
  private V1AlertmanagerSpecAlertmanagerConfigSelector alertmanagerConfigSelector;

  public static final String SERIALIZED_NAME_ALERTMANAGER_CONFIGURATION = "alertmanagerConfiguration";
  @SerializedName(SERIALIZED_NAME_ALERTMANAGER_CONFIGURATION)
  private V1AlertmanagerSpecAlertmanagerConfiguration alertmanagerConfiguration;

  public static final String SERIALIZED_NAME_BASE_IMAGE = "baseImage";
  @SerializedName(SERIALIZED_NAME_BASE_IMAGE)
  private String baseImage;

  public static final String SERIALIZED_NAME_CLUSTER_ADVERTISE_ADDRESS = "clusterAdvertiseAddress";
  @SerializedName(SERIALIZED_NAME_CLUSTER_ADVERTISE_ADDRESS)
  private String clusterAdvertiseAddress;

  public static final String SERIALIZED_NAME_CLUSTER_GOSSIP_INTERVAL = "clusterGossipInterval";
  @SerializedName(SERIALIZED_NAME_CLUSTER_GOSSIP_INTERVAL)
  private String clusterGossipInterval;

  public static final String SERIALIZED_NAME_CLUSTER_PEER_TIMEOUT = "clusterPeerTimeout";
  @SerializedName(SERIALIZED_NAME_CLUSTER_PEER_TIMEOUT)
  private String clusterPeerTimeout;

  public static final String SERIALIZED_NAME_CLUSTER_PUSHPULL_INTERVAL = "clusterPushpullInterval";
  @SerializedName(SERIALIZED_NAME_CLUSTER_PUSHPULL_INTERVAL)
  private String clusterPushpullInterval;

  public static final String SERIALIZED_NAME_CONFIG_MAPS = "configMaps";
  @SerializedName(SERIALIZED_NAME_CONFIG_MAPS)
  private List<String> configMaps;

  public static final String SERIALIZED_NAME_CONFIG_SECRET = "configSecret";
  @SerializedName(SERIALIZED_NAME_CONFIG_SECRET)
  private String configSecret;

  public static final String SERIALIZED_NAME_CONTAINERS = "containers";
  @SerializedName(SERIALIZED_NAME_CONTAINERS)
  private List<V1AlertmanagerSpecContainersInner> containers;

  public static final String SERIALIZED_NAME_EXTERNAL_URL = "externalUrl";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_URL)
  private String externalUrl;

  public static final String SERIALIZED_NAME_FORCE_ENABLE_CLUSTER_MODE = "forceEnableClusterMode";
  @SerializedName(SERIALIZED_NAME_FORCE_ENABLE_CLUSTER_MODE)
  private Boolean forceEnableClusterMode;

  public static final String SERIALIZED_NAME_HOST_ALIASES = "hostAliases";
  @SerializedName(SERIALIZED_NAME_HOST_ALIASES)
  private List<V1AlertmanagerSpecHostAliasesInner> hostAliases;

  public static final String SERIALIZED_NAME_IMAGE = "image";
  @SerializedName(SERIALIZED_NAME_IMAGE)
  private String image;

  /**
   * Image pull policy for the &#39;alertmanager&#39;, &#39;init-config-reloader&#39; and &#39;config-reloader&#39; containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   */
  @JsonAdapter(ImagePullPolicyEnum.Adapter.class)
  public enum ImagePullPolicyEnum {
    EMPTY(""),
    
    ALWAYS("Always"),
    
    NEVER("Never"),
    
    IFNOTPRESENT("IfNotPresent");

    private String value;

    ImagePullPolicyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ImagePullPolicyEnum fromValue(String value) {
      for (ImagePullPolicyEnum b : ImagePullPolicyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ImagePullPolicyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ImagePullPolicyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ImagePullPolicyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ImagePullPolicyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_IMAGE_PULL_POLICY = "imagePullPolicy";
  @SerializedName(SERIALIZED_NAME_IMAGE_PULL_POLICY)
  private ImagePullPolicyEnum imagePullPolicy;

  public static final String SERIALIZED_NAME_IMAGE_PULL_SECRETS = "imagePullSecrets";
  @SerializedName(SERIALIZED_NAME_IMAGE_PULL_SECRETS)
  private List<V1AlertmanagerSpecImagePullSecretsInner> imagePullSecrets;

  public static final String SERIALIZED_NAME_INIT_CONTAINERS = "initContainers";
  @SerializedName(SERIALIZED_NAME_INIT_CONTAINERS)
  private List<V1AlertmanagerSpecContainersInner> initContainers;

  public static final String SERIALIZED_NAME_LISTEN_LOCAL = "listenLocal";
  @SerializedName(SERIALIZED_NAME_LISTEN_LOCAL)
  private Boolean listenLocal;

  /**
   * Log format for Alertmanager to be configured with.
   */
  @JsonAdapter(LogFormatEnum.Adapter.class)
  public enum LogFormatEnum {
    EMPTY(""),
    
    LOGFMT("logfmt"),
    
    JSON("json");

    private String value;

    LogFormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LogFormatEnum fromValue(String value) {
      for (LogFormatEnum b : LogFormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LogFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogFormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LogFormatEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LOG_FORMAT = "logFormat";
  @SerializedName(SERIALIZED_NAME_LOG_FORMAT)
  private LogFormatEnum logFormat;

  /**
   * Log level for Alertmanager to be configured with.
   */
  @JsonAdapter(LogLevelEnum.Adapter.class)
  public enum LogLevelEnum {
    EMPTY(""),
    
    DEBUG("debug"),
    
    INFO("info"),
    
    WARN("warn"),
    
    ERROR("error");

    private String value;

    LogLevelEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static LogLevelEnum fromValue(String value) {
      for (LogLevelEnum b : LogLevelEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<LogLevelEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final LogLevelEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public LogLevelEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return LogLevelEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_LOG_LEVEL = "logLevel";
  @SerializedName(SERIALIZED_NAME_LOG_LEVEL)
  private LogLevelEnum logLevel;

  public static final String SERIALIZED_NAME_MIN_READY_SECONDS = "minReadySeconds";
  @SerializedName(SERIALIZED_NAME_MIN_READY_SECONDS)
  private Integer minReadySeconds;

  public static final String SERIALIZED_NAME_NODE_SELECTOR = "nodeSelector";
  @SerializedName(SERIALIZED_NAME_NODE_SELECTOR)
  private Map<String, String> nodeSelector = new HashMap<>();

  public static final String SERIALIZED_NAME_PAUSED = "paused";
  @SerializedName(SERIALIZED_NAME_PAUSED)
  private Boolean paused;

  public static final String SERIALIZED_NAME_POD_METADATA = "podMetadata";
  @SerializedName(SERIALIZED_NAME_POD_METADATA)
  private V1AlertmanagerSpecPodMetadata podMetadata;

  public static final String SERIALIZED_NAME_PORT_NAME = "portName";
  @SerializedName(SERIALIZED_NAME_PORT_NAME)
  private String portName;

  public static final String SERIALIZED_NAME_PRIORITY_CLASS_NAME = "priorityClassName";
  @SerializedName(SERIALIZED_NAME_PRIORITY_CLASS_NAME)
  private String priorityClassName;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private Integer replicas;

  public static final String SERIALIZED_NAME_RESOURCES = "resources";
  @SerializedName(SERIALIZED_NAME_RESOURCES)
  private V1AlertmanagerSpecResources resources;

  public static final String SERIALIZED_NAME_RETENTION = "retention";
  @SerializedName(SERIALIZED_NAME_RETENTION)
  private String retention;

  public static final String SERIALIZED_NAME_ROUTE_PREFIX = "routePrefix";
  @SerializedName(SERIALIZED_NAME_ROUTE_PREFIX)
  private String routePrefix;

  public static final String SERIALIZED_NAME_SECRETS = "secrets";
  @SerializedName(SERIALIZED_NAME_SECRETS)
  private List<String> secrets;

  public static final String SERIALIZED_NAME_SECURITY_CONTEXT = "securityContext";
  @SerializedName(SERIALIZED_NAME_SECURITY_CONTEXT)
  private V1AlertmanagerSpecSecurityContext securityContext;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_NAME = "serviceAccountName";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_NAME)
  private String serviceAccountName;

  public static final String SERIALIZED_NAME_SHA = "sha";
  @SerializedName(SERIALIZED_NAME_SHA)
  private String sha;

  public static final String SERIALIZED_NAME_STORAGE = "storage";
  @SerializedName(SERIALIZED_NAME_STORAGE)
  private V1AlertmanagerSpecStorage storage;

  public static final String SERIALIZED_NAME_TAG = "tag";
  @SerializedName(SERIALIZED_NAME_TAG)
  private String tag;

  public static final String SERIALIZED_NAME_TOLERATIONS = "tolerations";
  @SerializedName(SERIALIZED_NAME_TOLERATIONS)
  private List<V1AlertmanagerSpecTolerationsInner> tolerations;

  public static final String SERIALIZED_NAME_TOPOLOGY_SPREAD_CONSTRAINTS = "topologySpreadConstraints";
  @SerializedName(SERIALIZED_NAME_TOPOLOGY_SPREAD_CONSTRAINTS)
  private List<V1AlertmanagerSpecTopologySpreadConstraintsInner> topologySpreadConstraints;

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  private String version;

  public static final String SERIALIZED_NAME_VOLUME_MOUNTS = "volumeMounts";
  @SerializedName(SERIALIZED_NAME_VOLUME_MOUNTS)
  private List<V1AlertmanagerSpecContainersInnerVolumeMountsInner> volumeMounts;

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private List<V1AlertmanagerSpecVolumesInner> volumes;

  public static final String SERIALIZED_NAME_WEB = "web";
  @SerializedName(SERIALIZED_NAME_WEB)
  private V1AlertmanagerSpecWeb web;

  public V1AlertmanagerSpec() {
  }

  public V1AlertmanagerSpec additionalPeers(List<String> additionalPeers) {
    
    this.additionalPeers = additionalPeers;
    return this;
  }

  public V1AlertmanagerSpec addAdditionalPeersItem(String additionalPeersItem) {
    if (this.additionalPeers == null) {
      this.additionalPeers = new ArrayList<>();
    }
    this.additionalPeers.add(additionalPeersItem);
    return this;
  }

   /**
   * AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
   * @return additionalPeers
  **/
  @jakarta.annotation.Nullable
  public List<String> getAdditionalPeers() {
    return additionalPeers;
  }


  public void setAdditionalPeers(List<String> additionalPeers) {
    this.additionalPeers = additionalPeers;
  }


  public V1AlertmanagerSpec affinity(V1AlertmanagerSpecAffinity affinity) {
    
    this.affinity = affinity;
    return this;
  }

   /**
   * Get affinity
   * @return affinity
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecAffinity getAffinity() {
    return affinity;
  }


  public void setAffinity(V1AlertmanagerSpecAffinity affinity) {
    this.affinity = affinity;
  }


  public V1AlertmanagerSpec alertmanagerConfigMatcherStrategy(V1AlertmanagerSpecAlertmanagerConfigMatcherStrategy alertmanagerConfigMatcherStrategy) {
    
    this.alertmanagerConfigMatcherStrategy = alertmanagerConfigMatcherStrategy;
    return this;
  }

   /**
   * Get alertmanagerConfigMatcherStrategy
   * @return alertmanagerConfigMatcherStrategy
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecAlertmanagerConfigMatcherStrategy getAlertmanagerConfigMatcherStrategy() {
    return alertmanagerConfigMatcherStrategy;
  }


  public void setAlertmanagerConfigMatcherStrategy(V1AlertmanagerSpecAlertmanagerConfigMatcherStrategy alertmanagerConfigMatcherStrategy) {
    this.alertmanagerConfigMatcherStrategy = alertmanagerConfigMatcherStrategy;
  }


  public V1AlertmanagerSpec alertmanagerConfigNamespaceSelector(V1AlertmanagerSpecAlertmanagerConfigNamespaceSelector alertmanagerConfigNamespaceSelector) {
    
    this.alertmanagerConfigNamespaceSelector = alertmanagerConfigNamespaceSelector;
    return this;
  }

   /**
   * Get alertmanagerConfigNamespaceSelector
   * @return alertmanagerConfigNamespaceSelector
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecAlertmanagerConfigNamespaceSelector getAlertmanagerConfigNamespaceSelector() {
    return alertmanagerConfigNamespaceSelector;
  }


  public void setAlertmanagerConfigNamespaceSelector(V1AlertmanagerSpecAlertmanagerConfigNamespaceSelector alertmanagerConfigNamespaceSelector) {
    this.alertmanagerConfigNamespaceSelector = alertmanagerConfigNamespaceSelector;
  }


  public V1AlertmanagerSpec alertmanagerConfigSelector(V1AlertmanagerSpecAlertmanagerConfigSelector alertmanagerConfigSelector) {
    
    this.alertmanagerConfigSelector = alertmanagerConfigSelector;
    return this;
  }

   /**
   * Get alertmanagerConfigSelector
   * @return alertmanagerConfigSelector
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecAlertmanagerConfigSelector getAlertmanagerConfigSelector() {
    return alertmanagerConfigSelector;
  }


  public void setAlertmanagerConfigSelector(V1AlertmanagerSpecAlertmanagerConfigSelector alertmanagerConfigSelector) {
    this.alertmanagerConfigSelector = alertmanagerConfigSelector;
  }


  public V1AlertmanagerSpec alertmanagerConfiguration(V1AlertmanagerSpecAlertmanagerConfiguration alertmanagerConfiguration) {
    
    this.alertmanagerConfiguration = alertmanagerConfiguration;
    return this;
  }

   /**
   * Get alertmanagerConfiguration
   * @return alertmanagerConfiguration
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecAlertmanagerConfiguration getAlertmanagerConfiguration() {
    return alertmanagerConfiguration;
  }


  public void setAlertmanagerConfiguration(V1AlertmanagerSpecAlertmanagerConfiguration alertmanagerConfiguration) {
    this.alertmanagerConfiguration = alertmanagerConfiguration;
  }


  public V1AlertmanagerSpec baseImage(String baseImage) {
    
    this.baseImage = baseImage;
    return this;
  }

   /**
   * Base image that is used to deploy pods, without tag. Deprecated: use &#39;image&#39; instead
   * @return baseImage
  **/
  @jakarta.annotation.Nullable
  public String getBaseImage() {
    return baseImage;
  }


  public void setBaseImage(String baseImage) {
    this.baseImage = baseImage;
  }


  public V1AlertmanagerSpec clusterAdvertiseAddress(String clusterAdvertiseAddress) {
    
    this.clusterAdvertiseAddress = clusterAdvertiseAddress;
    return this;
  }

   /**
   * ClusterAdvertiseAddress is the explicit address to advertise in cluster. Needs to be provided for non RFC1918 [1] (public) addresses. [1] RFC1918: https://tools.ietf.org/html/rfc1918
   * @return clusterAdvertiseAddress
  **/
  @jakarta.annotation.Nullable
  public String getClusterAdvertiseAddress() {
    return clusterAdvertiseAddress;
  }


  public void setClusterAdvertiseAddress(String clusterAdvertiseAddress) {
    this.clusterAdvertiseAddress = clusterAdvertiseAddress;
  }


  public V1AlertmanagerSpec clusterGossipInterval(String clusterGossipInterval) {
    
    this.clusterGossipInterval = clusterGossipInterval;
    return this;
  }

   /**
   * Interval between gossip attempts.
   * @return clusterGossipInterval
  **/
  @jakarta.annotation.Nullable
  public String getClusterGossipInterval() {
    return clusterGossipInterval;
  }


  public void setClusterGossipInterval(String clusterGossipInterval) {
    this.clusterGossipInterval = clusterGossipInterval;
  }


  public V1AlertmanagerSpec clusterPeerTimeout(String clusterPeerTimeout) {
    
    this.clusterPeerTimeout = clusterPeerTimeout;
    return this;
  }

   /**
   * Timeout for cluster peering.
   * @return clusterPeerTimeout
  **/
  @jakarta.annotation.Nullable
  public String getClusterPeerTimeout() {
    return clusterPeerTimeout;
  }


  public void setClusterPeerTimeout(String clusterPeerTimeout) {
    this.clusterPeerTimeout = clusterPeerTimeout;
  }


  public V1AlertmanagerSpec clusterPushpullInterval(String clusterPushpullInterval) {
    
    this.clusterPushpullInterval = clusterPushpullInterval;
    return this;
  }

   /**
   * Interval between pushpull attempts.
   * @return clusterPushpullInterval
  **/
  @jakarta.annotation.Nullable
  public String getClusterPushpullInterval() {
    return clusterPushpullInterval;
  }


  public void setClusterPushpullInterval(String clusterPushpullInterval) {
    this.clusterPushpullInterval = clusterPushpullInterval;
  }


  public V1AlertmanagerSpec configMaps(List<String> configMaps) {
    
    this.configMaps = configMaps;
    return this;
  }

  public V1AlertmanagerSpec addConfigMapsItem(String configMapsItem) {
    if (this.configMaps == null) {
      this.configMaps = new ArrayList<>();
    }
    this.configMaps.add(configMapsItem);
    return this;
  }

   /**
   * ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. Each ConfigMap is added to the StatefulSet definition as a volume named &#x60;configmap-&lt;configmap-name&gt;&#x60;. The ConfigMaps are mounted into &#x60;/etc/alertmanager/configmaps/&lt;configmap-name&gt;&#x60; in the &#39;alertmanager&#39; container.
   * @return configMaps
  **/
  @jakarta.annotation.Nullable
  public List<String> getConfigMaps() {
    return configMaps;
  }


  public void setConfigMaps(List<String> configMaps) {
    this.configMaps = configMaps;
  }


  public V1AlertmanagerSpec configSecret(String configSecret) {
    
    this.configSecret = configSecret;
    return this;
  }

   /**
   * ConfigSecret is the name of a Kubernetes Secret in the same namespace as the Alertmanager object, which contains the configuration for this Alertmanager instance. If empty, it defaults to &#x60;alertmanager-&lt;alertmanager-name&gt;&#x60;.   The Alertmanager configuration should be available under the &#x60;alertmanager.yaml&#x60; key. Additional keys from the original secret are copied to the generated secret and mounted into the &#x60;/etc/alertmanager/config&#x60; directory in the &#x60;alertmanager&#x60; container.   If either the secret or the &#x60;alertmanager.yaml&#x60; key is missing, the operator provisions a minimal Alertmanager configuration with one empty receiver (effectively dropping alert notifications).
   * @return configSecret
  **/
  @jakarta.annotation.Nullable
  public String getConfigSecret() {
    return configSecret;
  }


  public void setConfigSecret(String configSecret) {
    this.configSecret = configSecret;
  }


  public V1AlertmanagerSpec containers(List<V1AlertmanagerSpecContainersInner> containers) {
    
    this.containers = containers;
    return this;
  }

  public V1AlertmanagerSpec addContainersItem(V1AlertmanagerSpecContainersInner containersItem) {
    if (this.containers == null) {
      this.containers = new ArrayList<>();
    }
    this.containers.add(containersItem);
    return this;
  }

   /**
   * Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod. Containers described here modify an operator generated container if they share the same name and modifications are done via a strategic merge patch. The current container names are: &#x60;alertmanager&#x60; and &#x60;config-reloader&#x60;. Overriding containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   * @return containers
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecContainersInner> getContainers() {
    return containers;
  }


  public void setContainers(List<V1AlertmanagerSpecContainersInner> containers) {
    this.containers = containers;
  }


  public V1AlertmanagerSpec externalUrl(String externalUrl) {
    
    this.externalUrl = externalUrl;
    return this;
  }

   /**
   * The external URL the Alertmanager instances will be available under. This is necessary to generate correct URLs. This is necessary if Alertmanager is not served from root of a DNS name.
   * @return externalUrl
  **/
  @jakarta.annotation.Nullable
  public String getExternalUrl() {
    return externalUrl;
  }


  public void setExternalUrl(String externalUrl) {
    this.externalUrl = externalUrl;
  }


  public V1AlertmanagerSpec forceEnableClusterMode(Boolean forceEnableClusterMode) {
    
    this.forceEnableClusterMode = forceEnableClusterMode;
    return this;
  }

   /**
   * ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica. Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
   * @return forceEnableClusterMode
  **/
  @jakarta.annotation.Nullable
  public Boolean getForceEnableClusterMode() {
    return forceEnableClusterMode;
  }


  public void setForceEnableClusterMode(Boolean forceEnableClusterMode) {
    this.forceEnableClusterMode = forceEnableClusterMode;
  }


  public V1AlertmanagerSpec hostAliases(List<V1AlertmanagerSpecHostAliasesInner> hostAliases) {
    
    this.hostAliases = hostAliases;
    return this;
  }

  public V1AlertmanagerSpec addHostAliasesItem(V1AlertmanagerSpecHostAliasesInner hostAliasesItem) {
    if (this.hostAliases == null) {
      this.hostAliases = new ArrayList<>();
    }
    this.hostAliases.add(hostAliasesItem);
    return this;
  }

   /**
   * Pods&#39; hostAliases configuration
   * @return hostAliases
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecHostAliasesInner> getHostAliases() {
    return hostAliases;
  }


  public void setHostAliases(List<V1AlertmanagerSpecHostAliasesInner> hostAliases) {
    this.hostAliases = hostAliases;
  }


  public V1AlertmanagerSpec image(String image) {
    
    this.image = image;
    return this;
  }

   /**
   * Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Alertmanager is being configured.
   * @return image
  **/
  @jakarta.annotation.Nullable
  public String getImage() {
    return image;
  }


  public void setImage(String image) {
    this.image = image;
  }


  public V1AlertmanagerSpec imagePullPolicy(ImagePullPolicyEnum imagePullPolicy) {
    
    this.imagePullPolicy = imagePullPolicy;
    return this;
  }

   /**
   * Image pull policy for the &#39;alertmanager&#39;, &#39;init-config-reloader&#39; and &#39;config-reloader&#39; containers. See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
   * @return imagePullPolicy
  **/
  @jakarta.annotation.Nullable
  public ImagePullPolicyEnum getImagePullPolicy() {
    return imagePullPolicy;
  }


  public void setImagePullPolicy(ImagePullPolicyEnum imagePullPolicy) {
    this.imagePullPolicy = imagePullPolicy;
  }


  public V1AlertmanagerSpec imagePullSecrets(List<V1AlertmanagerSpecImagePullSecretsInner> imagePullSecrets) {
    
    this.imagePullSecrets = imagePullSecrets;
    return this;
  }

  public V1AlertmanagerSpec addImagePullSecretsItem(V1AlertmanagerSpecImagePullSecretsInner imagePullSecretsItem) {
    if (this.imagePullSecrets == null) {
      this.imagePullSecrets = new ArrayList<>();
    }
    this.imagePullSecrets.add(imagePullSecretsItem);
    return this;
  }

   /**
   * An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
   * @return imagePullSecrets
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecImagePullSecretsInner> getImagePullSecrets() {
    return imagePullSecrets;
  }


  public void setImagePullSecrets(List<V1AlertmanagerSpecImagePullSecretsInner> imagePullSecrets) {
    this.imagePullSecrets = imagePullSecrets;
  }


  public V1AlertmanagerSpec initContainers(List<V1AlertmanagerSpecContainersInner> initContainers) {
    
    this.initContainers = initContainers;
    return this;
  }

  public V1AlertmanagerSpec addInitContainersItem(V1AlertmanagerSpecContainersInner initContainersItem) {
    if (this.initContainers == null) {
      this.initContainers = new ArrayList<>();
    }
    this.initContainers.add(initContainersItem);
    return this;
  }

   /**
   * InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the Alertmanager configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ InitContainers described here modify an operator generated init containers if they share the same name and modifications are done via a strategic merge patch. The current init container name is: &#x60;init-config-reloader&#x60;. Overriding init containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
   * @return initContainers
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecContainersInner> getInitContainers() {
    return initContainers;
  }


  public void setInitContainers(List<V1AlertmanagerSpecContainersInner> initContainers) {
    this.initContainers = initContainers;
  }


  public V1AlertmanagerSpec listenLocal(Boolean listenLocal) {
    
    this.listenLocal = listenLocal;
    return this;
  }

   /**
   * ListenLocal makes the Alertmanager server listen on loopback, so that it does not bind against the Pod IP. Note this is only for the Alertmanager UI, not the gossip communication.
   * @return listenLocal
  **/
  @jakarta.annotation.Nullable
  public Boolean getListenLocal() {
    return listenLocal;
  }


  public void setListenLocal(Boolean listenLocal) {
    this.listenLocal = listenLocal;
  }


  public V1AlertmanagerSpec logFormat(LogFormatEnum logFormat) {
    
    this.logFormat = logFormat;
    return this;
  }

   /**
   * Log format for Alertmanager to be configured with.
   * @return logFormat
  **/
  @jakarta.annotation.Nullable
  public LogFormatEnum getLogFormat() {
    return logFormat;
  }


  public void setLogFormat(LogFormatEnum logFormat) {
    this.logFormat = logFormat;
  }


  public V1AlertmanagerSpec logLevel(LogLevelEnum logLevel) {
    
    this.logLevel = logLevel;
    return this;
  }

   /**
   * Log level for Alertmanager to be configured with.
   * @return logLevel
  **/
  @jakarta.annotation.Nullable
  public LogLevelEnum getLogLevel() {
    return logLevel;
  }


  public void setLogLevel(LogLevelEnum logLevel) {
    this.logLevel = logLevel;
  }


  public V1AlertmanagerSpec minReadySeconds(Integer minReadySeconds) {
    
    this.minReadySeconds = minReadySeconds;
    return this;
  }

   /**
   * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready) This is an alpha field from kubernetes 1.22 until 1.24 which requires enabling the StatefulSetMinReadySeconds feature gate.
   * @return minReadySeconds
  **/
  @jakarta.annotation.Nullable
  public Integer getMinReadySeconds() {
    return minReadySeconds;
  }


  public void setMinReadySeconds(Integer minReadySeconds) {
    this.minReadySeconds = minReadySeconds;
  }


  public V1AlertmanagerSpec nodeSelector(Map<String, String> nodeSelector) {
    
    this.nodeSelector = nodeSelector;
    return this;
  }

  public V1AlertmanagerSpec putNodeSelectorItem(String key, String nodeSelectorItem) {
    if (this.nodeSelector == null) {
      this.nodeSelector = new HashMap<>();
    }
    this.nodeSelector.put(key, nodeSelectorItem);
    return this;
  }

   /**
   * Define which Nodes the Pods are scheduled on.
   * @return nodeSelector
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getNodeSelector() {
    return nodeSelector;
  }


  public void setNodeSelector(Map<String, String> nodeSelector) {
    this.nodeSelector = nodeSelector;
  }


  public V1AlertmanagerSpec paused(Boolean paused) {
    
    this.paused = paused;
    return this;
  }

   /**
   * If set to true all actions on the underlying managed objects are not goint to be performed, except for delete actions.
   * @return paused
  **/
  @jakarta.annotation.Nullable
  public Boolean getPaused() {
    return paused;
  }


  public void setPaused(Boolean paused) {
    this.paused = paused;
  }


  public V1AlertmanagerSpec podMetadata(V1AlertmanagerSpecPodMetadata podMetadata) {
    
    this.podMetadata = podMetadata;
    return this;
  }

   /**
   * Get podMetadata
   * @return podMetadata
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecPodMetadata getPodMetadata() {
    return podMetadata;
  }


  public void setPodMetadata(V1AlertmanagerSpecPodMetadata podMetadata) {
    this.podMetadata = podMetadata;
  }


  public V1AlertmanagerSpec portName(String portName) {
    
    this.portName = portName;
    return this;
  }

   /**
   * Port name used for the pods and governing service. Defaults to &#x60;web&#x60;.
   * @return portName
  **/
  @jakarta.annotation.Nullable
  public String getPortName() {
    return portName;
  }


  public void setPortName(String portName) {
    this.portName = portName;
  }


  public V1AlertmanagerSpec priorityClassName(String priorityClassName) {
    
    this.priorityClassName = priorityClassName;
    return this;
  }

   /**
   * Priority class assigned to the Pods
   * @return priorityClassName
  **/
  @jakarta.annotation.Nullable
  public String getPriorityClassName() {
    return priorityClassName;
  }


  public void setPriorityClassName(String priorityClassName) {
    this.priorityClassName = priorityClassName;
  }


  public V1AlertmanagerSpec replicas(Integer replicas) {
    
    this.replicas = replicas;
    return this;
  }

   /**
   * Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the running cluster equal to the expected size.
   * @return replicas
  **/
  @jakarta.annotation.Nullable
  public Integer getReplicas() {
    return replicas;
  }


  public void setReplicas(Integer replicas) {
    this.replicas = replicas;
  }


  public V1AlertmanagerSpec resources(V1AlertmanagerSpecResources resources) {
    
    this.resources = resources;
    return this;
  }

   /**
   * Get resources
   * @return resources
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecResources getResources() {
    return resources;
  }


  public void setResources(V1AlertmanagerSpecResources resources) {
    this.resources = resources;
  }


  public V1AlertmanagerSpec retention(String retention) {
    
    this.retention = retention;
    return this;
  }

   /**
   * Time duration Alertmanager shall retain data for. Default is &#39;120h&#39;, and must match the regular expression &#x60;[0-9]+(ms|s|m|h)&#x60; (milliseconds seconds minutes hours).
   * @return retention
  **/
  @jakarta.annotation.Nullable
  public String getRetention() {
    return retention;
  }


  public void setRetention(String retention) {
    this.retention = retention;
  }


  public V1AlertmanagerSpec routePrefix(String routePrefix) {
    
    this.routePrefix = routePrefix;
    return this;
  }

   /**
   * The route prefix Alertmanager registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with &#x60;kubectl proxy&#x60;.
   * @return routePrefix
  **/
  @jakarta.annotation.Nullable
  public String getRoutePrefix() {
    return routePrefix;
  }


  public void setRoutePrefix(String routePrefix) {
    this.routePrefix = routePrefix;
  }


  public V1AlertmanagerSpec secrets(List<String> secrets) {
    
    this.secrets = secrets;
    return this;
  }

  public V1AlertmanagerSpec addSecretsItem(String secretsItem) {
    if (this.secrets == null) {
      this.secrets = new ArrayList<>();
    }
    this.secrets.add(secretsItem);
    return this;
  }

   /**
   * Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. Each Secret is added to the StatefulSet definition as a volume named &#x60;secret-&lt;secret-name&gt;&#x60;. The Secrets are mounted into &#x60;/etc/alertmanager/secrets/&lt;secret-name&gt;&#x60; in the &#39;alertmanager&#39; container.
   * @return secrets
  **/
  @jakarta.annotation.Nullable
  public List<String> getSecrets() {
    return secrets;
  }


  public void setSecrets(List<String> secrets) {
    this.secrets = secrets;
  }


  public V1AlertmanagerSpec securityContext(V1AlertmanagerSpecSecurityContext securityContext) {
    
    this.securityContext = securityContext;
    return this;
  }

   /**
   * Get securityContext
   * @return securityContext
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecSecurityContext getSecurityContext() {
    return securityContext;
  }


  public void setSecurityContext(V1AlertmanagerSpecSecurityContext securityContext) {
    this.securityContext = securityContext;
  }


  public V1AlertmanagerSpec serviceAccountName(String serviceAccountName) {
    
    this.serviceAccountName = serviceAccountName;
    return this;
  }

   /**
   * ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.
   * @return serviceAccountName
  **/
  @jakarta.annotation.Nullable
  public String getServiceAccountName() {
    return serviceAccountName;
  }


  public void setServiceAccountName(String serviceAccountName) {
    this.serviceAccountName = serviceAccountName;
  }


  public V1AlertmanagerSpec sha(String sha) {
    
    this.sha = sha;
    return this;
  }

   /**
   * SHA of Alertmanager container image to be deployed. Defaults to the value of &#x60;version&#x60;. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set. Deprecated: use &#39;image&#39; instead.  The image digest can be specified as part of the image URL.
   * @return sha
  **/
  @jakarta.annotation.Nullable
  public String getSha() {
    return sha;
  }


  public void setSha(String sha) {
    this.sha = sha;
  }


  public V1AlertmanagerSpec storage(V1AlertmanagerSpecStorage storage) {
    
    this.storage = storage;
    return this;
  }

   /**
   * Get storage
   * @return storage
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecStorage getStorage() {
    return storage;
  }


  public void setStorage(V1AlertmanagerSpecStorage storage) {
    this.storage = storage;
  }


  public V1AlertmanagerSpec tag(String tag) {
    
    this.tag = tag;
    return this;
  }

   /**
   * Tag of Alertmanager container image to be deployed. Defaults to the value of &#x60;version&#x60;. Version is ignored if Tag is set. Deprecated: use &#39;image&#39; instead.  The image tag can be specified as part of the image URL.
   * @return tag
  **/
  @jakarta.annotation.Nullable
  public String getTag() {
    return tag;
  }


  public void setTag(String tag) {
    this.tag = tag;
  }


  public V1AlertmanagerSpec tolerations(List<V1AlertmanagerSpecTolerationsInner> tolerations) {
    
    this.tolerations = tolerations;
    return this;
  }

  public V1AlertmanagerSpec addTolerationsItem(V1AlertmanagerSpecTolerationsInner tolerationsItem) {
    if (this.tolerations == null) {
      this.tolerations = new ArrayList<>();
    }
    this.tolerations.add(tolerationsItem);
    return this;
  }

   /**
   * If specified, the pod&#39;s tolerations.
   * @return tolerations
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecTolerationsInner> getTolerations() {
    return tolerations;
  }


  public void setTolerations(List<V1AlertmanagerSpecTolerationsInner> tolerations) {
    this.tolerations = tolerations;
  }


  public V1AlertmanagerSpec topologySpreadConstraints(List<V1AlertmanagerSpecTopologySpreadConstraintsInner> topologySpreadConstraints) {
    
    this.topologySpreadConstraints = topologySpreadConstraints;
    return this;
  }

  public V1AlertmanagerSpec addTopologySpreadConstraintsItem(V1AlertmanagerSpecTopologySpreadConstraintsInner topologySpreadConstraintsItem) {
    if (this.topologySpreadConstraints == null) {
      this.topologySpreadConstraints = new ArrayList<>();
    }
    this.topologySpreadConstraints.add(topologySpreadConstraintsItem);
    return this;
  }

   /**
   * If specified, the pod&#39;s topology spread constraints.
   * @return topologySpreadConstraints
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecTopologySpreadConstraintsInner> getTopologySpreadConstraints() {
    return topologySpreadConstraints;
  }


  public void setTopologySpreadConstraints(List<V1AlertmanagerSpecTopologySpreadConstraintsInner> topologySpreadConstraints) {
    this.topologySpreadConstraints = topologySpreadConstraints;
  }


  public V1AlertmanagerSpec version(String version) {
    
    this.version = version;
    return this;
  }

   /**
   * Version the cluster should be on.
   * @return version
  **/
  @jakarta.annotation.Nullable
  public String getVersion() {
    return version;
  }


  public void setVersion(String version) {
    this.version = version;
  }


  public V1AlertmanagerSpec volumeMounts(List<V1AlertmanagerSpecContainersInnerVolumeMountsInner> volumeMounts) {
    
    this.volumeMounts = volumeMounts;
    return this;
  }

  public V1AlertmanagerSpec addVolumeMountsItem(V1AlertmanagerSpecContainersInnerVolumeMountsInner volumeMountsItem) {
    if (this.volumeMounts == null) {
      this.volumeMounts = new ArrayList<>();
    }
    this.volumeMounts.add(volumeMountsItem);
    return this;
  }

   /**
   * VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition. VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container, that are generated as a result of StorageSpec objects.
   * @return volumeMounts
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecContainersInnerVolumeMountsInner> getVolumeMounts() {
    return volumeMounts;
  }


  public void setVolumeMounts(List<V1AlertmanagerSpecContainersInnerVolumeMountsInner> volumeMounts) {
    this.volumeMounts = volumeMounts;
  }


  public V1AlertmanagerSpec volumes(List<V1AlertmanagerSpecVolumesInner> volumes) {
    
    this.volumes = volumes;
    return this;
  }

  public V1AlertmanagerSpec addVolumesItem(V1AlertmanagerSpecVolumesInner volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

   /**
   * Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.
   * @return volumes
  **/
  @jakarta.annotation.Nullable
  public List<V1AlertmanagerSpecVolumesInner> getVolumes() {
    return volumes;
  }


  public void setVolumes(List<V1AlertmanagerSpecVolumesInner> volumes) {
    this.volumes = volumes;
  }


  public V1AlertmanagerSpec web(V1AlertmanagerSpecWeb web) {
    
    this.web = web;
    return this;
  }

   /**
   * Get web
   * @return web
  **/
  @jakarta.annotation.Nullable
  public V1AlertmanagerSpecWeb getWeb() {
    return web;
  }


  public void setWeb(V1AlertmanagerSpecWeb web) {
    this.web = web;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1AlertmanagerSpec v1AlertmanagerSpec = (V1AlertmanagerSpec) o;
    return Objects.equals(this.additionalPeers, v1AlertmanagerSpec.additionalPeers) &&
        Objects.equals(this.affinity, v1AlertmanagerSpec.affinity) &&
        Objects.equals(this.alertmanagerConfigMatcherStrategy, v1AlertmanagerSpec.alertmanagerConfigMatcherStrategy) &&
        Objects.equals(this.alertmanagerConfigNamespaceSelector, v1AlertmanagerSpec.alertmanagerConfigNamespaceSelector) &&
        Objects.equals(this.alertmanagerConfigSelector, v1AlertmanagerSpec.alertmanagerConfigSelector) &&
        Objects.equals(this.alertmanagerConfiguration, v1AlertmanagerSpec.alertmanagerConfiguration) &&
        Objects.equals(this.baseImage, v1AlertmanagerSpec.baseImage) &&
        Objects.equals(this.clusterAdvertiseAddress, v1AlertmanagerSpec.clusterAdvertiseAddress) &&
        Objects.equals(this.clusterGossipInterval, v1AlertmanagerSpec.clusterGossipInterval) &&
        Objects.equals(this.clusterPeerTimeout, v1AlertmanagerSpec.clusterPeerTimeout) &&
        Objects.equals(this.clusterPushpullInterval, v1AlertmanagerSpec.clusterPushpullInterval) &&
        Objects.equals(this.configMaps, v1AlertmanagerSpec.configMaps) &&
        Objects.equals(this.configSecret, v1AlertmanagerSpec.configSecret) &&
        Objects.equals(this.containers, v1AlertmanagerSpec.containers) &&
        Objects.equals(this.externalUrl, v1AlertmanagerSpec.externalUrl) &&
        Objects.equals(this.forceEnableClusterMode, v1AlertmanagerSpec.forceEnableClusterMode) &&
        Objects.equals(this.hostAliases, v1AlertmanagerSpec.hostAliases) &&
        Objects.equals(this.image, v1AlertmanagerSpec.image) &&
        Objects.equals(this.imagePullPolicy, v1AlertmanagerSpec.imagePullPolicy) &&
        Objects.equals(this.imagePullSecrets, v1AlertmanagerSpec.imagePullSecrets) &&
        Objects.equals(this.initContainers, v1AlertmanagerSpec.initContainers) &&
        Objects.equals(this.listenLocal, v1AlertmanagerSpec.listenLocal) &&
        Objects.equals(this.logFormat, v1AlertmanagerSpec.logFormat) &&
        Objects.equals(this.logLevel, v1AlertmanagerSpec.logLevel) &&
        Objects.equals(this.minReadySeconds, v1AlertmanagerSpec.minReadySeconds) &&
        Objects.equals(this.nodeSelector, v1AlertmanagerSpec.nodeSelector) &&
        Objects.equals(this.paused, v1AlertmanagerSpec.paused) &&
        Objects.equals(this.podMetadata, v1AlertmanagerSpec.podMetadata) &&
        Objects.equals(this.portName, v1AlertmanagerSpec.portName) &&
        Objects.equals(this.priorityClassName, v1AlertmanagerSpec.priorityClassName) &&
        Objects.equals(this.replicas, v1AlertmanagerSpec.replicas) &&
        Objects.equals(this.resources, v1AlertmanagerSpec.resources) &&
        Objects.equals(this.retention, v1AlertmanagerSpec.retention) &&
        Objects.equals(this.routePrefix, v1AlertmanagerSpec.routePrefix) &&
        Objects.equals(this.secrets, v1AlertmanagerSpec.secrets) &&
        Objects.equals(this.securityContext, v1AlertmanagerSpec.securityContext) &&
        Objects.equals(this.serviceAccountName, v1AlertmanagerSpec.serviceAccountName) &&
        Objects.equals(this.sha, v1AlertmanagerSpec.sha) &&
        Objects.equals(this.storage, v1AlertmanagerSpec.storage) &&
        Objects.equals(this.tag, v1AlertmanagerSpec.tag) &&
        Objects.equals(this.tolerations, v1AlertmanagerSpec.tolerations) &&
        Objects.equals(this.topologySpreadConstraints, v1AlertmanagerSpec.topologySpreadConstraints) &&
        Objects.equals(this.version, v1AlertmanagerSpec.version) &&
        Objects.equals(this.volumeMounts, v1AlertmanagerSpec.volumeMounts) &&
        Objects.equals(this.volumes, v1AlertmanagerSpec.volumes) &&
        Objects.equals(this.web, v1AlertmanagerSpec.web);
  }

  @Override
  public int hashCode() {
    return Objects.hash(additionalPeers, affinity, alertmanagerConfigMatcherStrategy, alertmanagerConfigNamespaceSelector, alertmanagerConfigSelector, alertmanagerConfiguration, baseImage, clusterAdvertiseAddress, clusterGossipInterval, clusterPeerTimeout, clusterPushpullInterval, configMaps, configSecret, containers, externalUrl, forceEnableClusterMode, hostAliases, image, imagePullPolicy, imagePullSecrets, initContainers, listenLocal, logFormat, logLevel, minReadySeconds, nodeSelector, paused, podMetadata, portName, priorityClassName, replicas, resources, retention, routePrefix, secrets, securityContext, serviceAccountName, sha, storage, tag, tolerations, topologySpreadConstraints, version, volumeMounts, volumes, web);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1AlertmanagerSpec {\n");
    sb.append("    additionalPeers: ").append(toIndentedString(additionalPeers)).append("\n");
    sb.append("    affinity: ").append(toIndentedString(affinity)).append("\n");
    sb.append("    alertmanagerConfigMatcherStrategy: ").append(toIndentedString(alertmanagerConfigMatcherStrategy)).append("\n");
    sb.append("    alertmanagerConfigNamespaceSelector: ").append(toIndentedString(alertmanagerConfigNamespaceSelector)).append("\n");
    sb.append("    alertmanagerConfigSelector: ").append(toIndentedString(alertmanagerConfigSelector)).append("\n");
    sb.append("    alertmanagerConfiguration: ").append(toIndentedString(alertmanagerConfiguration)).append("\n");
    sb.append("    baseImage: ").append(toIndentedString(baseImage)).append("\n");
    sb.append("    clusterAdvertiseAddress: ").append(toIndentedString(clusterAdvertiseAddress)).append("\n");
    sb.append("    clusterGossipInterval: ").append(toIndentedString(clusterGossipInterval)).append("\n");
    sb.append("    clusterPeerTimeout: ").append(toIndentedString(clusterPeerTimeout)).append("\n");
    sb.append("    clusterPushpullInterval: ").append(toIndentedString(clusterPushpullInterval)).append("\n");
    sb.append("    configMaps: ").append(toIndentedString(configMaps)).append("\n");
    sb.append("    configSecret: ").append(toIndentedString(configSecret)).append("\n");
    sb.append("    containers: ").append(toIndentedString(containers)).append("\n");
    sb.append("    externalUrl: ").append(toIndentedString(externalUrl)).append("\n");
    sb.append("    forceEnableClusterMode: ").append(toIndentedString(forceEnableClusterMode)).append("\n");
    sb.append("    hostAliases: ").append(toIndentedString(hostAliases)).append("\n");
    sb.append("    image: ").append(toIndentedString(image)).append("\n");
    sb.append("    imagePullPolicy: ").append(toIndentedString(imagePullPolicy)).append("\n");
    sb.append("    imagePullSecrets: ").append(toIndentedString(imagePullSecrets)).append("\n");
    sb.append("    initContainers: ").append(toIndentedString(initContainers)).append("\n");
    sb.append("    listenLocal: ").append(toIndentedString(listenLocal)).append("\n");
    sb.append("    logFormat: ").append(toIndentedString(logFormat)).append("\n");
    sb.append("    logLevel: ").append(toIndentedString(logLevel)).append("\n");
    sb.append("    minReadySeconds: ").append(toIndentedString(minReadySeconds)).append("\n");
    sb.append("    nodeSelector: ").append(toIndentedString(nodeSelector)).append("\n");
    sb.append("    paused: ").append(toIndentedString(paused)).append("\n");
    sb.append("    podMetadata: ").append(toIndentedString(podMetadata)).append("\n");
    sb.append("    portName: ").append(toIndentedString(portName)).append("\n");
    sb.append("    priorityClassName: ").append(toIndentedString(priorityClassName)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    retention: ").append(toIndentedString(retention)).append("\n");
    sb.append("    routePrefix: ").append(toIndentedString(routePrefix)).append("\n");
    sb.append("    secrets: ").append(toIndentedString(secrets)).append("\n");
    sb.append("    securityContext: ").append(toIndentedString(securityContext)).append("\n");
    sb.append("    serviceAccountName: ").append(toIndentedString(serviceAccountName)).append("\n");
    sb.append("    sha: ").append(toIndentedString(sha)).append("\n");
    sb.append("    storage: ").append(toIndentedString(storage)).append("\n");
    sb.append("    tag: ").append(toIndentedString(tag)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("    topologySpreadConstraints: ").append(toIndentedString(topologySpreadConstraints)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    volumeMounts: ").append(toIndentedString(volumeMounts)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("    web: ").append(toIndentedString(web)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("additionalPeers");
    openapiFields.add("affinity");
    openapiFields.add("alertmanagerConfigMatcherStrategy");
    openapiFields.add("alertmanagerConfigNamespaceSelector");
    openapiFields.add("alertmanagerConfigSelector");
    openapiFields.add("alertmanagerConfiguration");
    openapiFields.add("baseImage");
    openapiFields.add("clusterAdvertiseAddress");
    openapiFields.add("clusterGossipInterval");
    openapiFields.add("clusterPeerTimeout");
    openapiFields.add("clusterPushpullInterval");
    openapiFields.add("configMaps");
    openapiFields.add("configSecret");
    openapiFields.add("containers");
    openapiFields.add("externalUrl");
    openapiFields.add("forceEnableClusterMode");
    openapiFields.add("hostAliases");
    openapiFields.add("image");
    openapiFields.add("imagePullPolicy");
    openapiFields.add("imagePullSecrets");
    openapiFields.add("initContainers");
    openapiFields.add("listenLocal");
    openapiFields.add("logFormat");
    openapiFields.add("logLevel");
    openapiFields.add("minReadySeconds");
    openapiFields.add("nodeSelector");
    openapiFields.add("paused");
    openapiFields.add("podMetadata");
    openapiFields.add("portName");
    openapiFields.add("priorityClassName");
    openapiFields.add("replicas");
    openapiFields.add("resources");
    openapiFields.add("retention");
    openapiFields.add("routePrefix");
    openapiFields.add("secrets");
    openapiFields.add("securityContext");
    openapiFields.add("serviceAccountName");
    openapiFields.add("sha");
    openapiFields.add("storage");
    openapiFields.add("tag");
    openapiFields.add("tolerations");
    openapiFields.add("topologySpreadConstraints");
    openapiFields.add("version");
    openapiFields.add("volumeMounts");
    openapiFields.add("volumes");
    openapiFields.add("web");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1AlertmanagerSpec
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1AlertmanagerSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1AlertmanagerSpec is not found in the empty JSON string", V1AlertmanagerSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1AlertmanagerSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1AlertmanagerSpec` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("additionalPeers") != null && !jsonObj.get("additionalPeers").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `additionalPeers` to be an array in the JSON string but got `%s`", jsonObj.get("additionalPeers").toString()));
      }
      // validate the optional field `affinity`
      if (jsonObj.get("affinity") != null && !jsonObj.get("affinity").isJsonNull()) {
        V1AlertmanagerSpecAffinity.validateJsonObject(jsonObj.getAsJsonObject("affinity"));
      }
      // validate the optional field `alertmanagerConfigMatcherStrategy`
      if (jsonObj.get("alertmanagerConfigMatcherStrategy") != null && !jsonObj.get("alertmanagerConfigMatcherStrategy").isJsonNull()) {
        V1AlertmanagerSpecAlertmanagerConfigMatcherStrategy.validateJsonObject(jsonObj.getAsJsonObject("alertmanagerConfigMatcherStrategy"));
      }
      // validate the optional field `alertmanagerConfigNamespaceSelector`
      if (jsonObj.get("alertmanagerConfigNamespaceSelector") != null && !jsonObj.get("alertmanagerConfigNamespaceSelector").isJsonNull()) {
        V1AlertmanagerSpecAlertmanagerConfigNamespaceSelector.validateJsonObject(jsonObj.getAsJsonObject("alertmanagerConfigNamespaceSelector"));
      }
      // validate the optional field `alertmanagerConfigSelector`
      if (jsonObj.get("alertmanagerConfigSelector") != null && !jsonObj.get("alertmanagerConfigSelector").isJsonNull()) {
        V1AlertmanagerSpecAlertmanagerConfigSelector.validateJsonObject(jsonObj.getAsJsonObject("alertmanagerConfigSelector"));
      }
      // validate the optional field `alertmanagerConfiguration`
      if (jsonObj.get("alertmanagerConfiguration") != null && !jsonObj.get("alertmanagerConfiguration").isJsonNull()) {
        V1AlertmanagerSpecAlertmanagerConfiguration.validateJsonObject(jsonObj.getAsJsonObject("alertmanagerConfiguration"));
      }
      if ((jsonObj.get("baseImage") != null && !jsonObj.get("baseImage").isJsonNull()) && !jsonObj.get("baseImage").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `baseImage` to be a primitive type in the JSON string but got `%s`", jsonObj.get("baseImage").toString()));
      }
      if ((jsonObj.get("clusterAdvertiseAddress") != null && !jsonObj.get("clusterAdvertiseAddress").isJsonNull()) && !jsonObj.get("clusterAdvertiseAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterAdvertiseAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterAdvertiseAddress").toString()));
      }
      if ((jsonObj.get("clusterGossipInterval") != null && !jsonObj.get("clusterGossipInterval").isJsonNull()) && !jsonObj.get("clusterGossipInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterGossipInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterGossipInterval").toString()));
      }
      if ((jsonObj.get("clusterPeerTimeout") != null && !jsonObj.get("clusterPeerTimeout").isJsonNull()) && !jsonObj.get("clusterPeerTimeout").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterPeerTimeout` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterPeerTimeout").toString()));
      }
      if ((jsonObj.get("clusterPushpullInterval") != null && !jsonObj.get("clusterPushpullInterval").isJsonNull()) && !jsonObj.get("clusterPushpullInterval").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `clusterPushpullInterval` to be a primitive type in the JSON string but got `%s`", jsonObj.get("clusterPushpullInterval").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("configMaps") != null && !jsonObj.get("configMaps").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `configMaps` to be an array in the JSON string but got `%s`", jsonObj.get("configMaps").toString()));
      }
      if ((jsonObj.get("configSecret") != null && !jsonObj.get("configSecret").isJsonNull()) && !jsonObj.get("configSecret").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `configSecret` to be a primitive type in the JSON string but got `%s`", jsonObj.get("configSecret").toString()));
      }
      if (jsonObj.get("containers") != null && !jsonObj.get("containers").isJsonNull()) {
        JsonArray jsonArraycontainers = jsonObj.getAsJsonArray("containers");
        if (jsonArraycontainers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("containers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `containers` to be an array in the JSON string but got `%s`", jsonObj.get("containers").toString()));
          }

          // validate the optional field `containers` (array)
          for (int i = 0; i < jsonArraycontainers.size(); i++) {
            V1AlertmanagerSpecContainersInner.validateJsonObject(jsonArraycontainers.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("externalUrl") != null && !jsonObj.get("externalUrl").isJsonNull()) && !jsonObj.get("externalUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalUrl").toString()));
      }
      if (jsonObj.get("hostAliases") != null && !jsonObj.get("hostAliases").isJsonNull()) {
        JsonArray jsonArrayhostAliases = jsonObj.getAsJsonArray("hostAliases");
        if (jsonArrayhostAliases != null) {
          // ensure the json data is an array
          if (!jsonObj.get("hostAliases").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `hostAliases` to be an array in the JSON string but got `%s`", jsonObj.get("hostAliases").toString()));
          }

          // validate the optional field `hostAliases` (array)
          for (int i = 0; i < jsonArrayhostAliases.size(); i++) {
            V1AlertmanagerSpecHostAliasesInner.validateJsonObject(jsonArrayhostAliases.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("image") != null && !jsonObj.get("image").isJsonNull()) && !jsonObj.get("image").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `image` to be a primitive type in the JSON string but got `%s`", jsonObj.get("image").toString()));
      }
      if ((jsonObj.get("imagePullPolicy") != null && !jsonObj.get("imagePullPolicy").isJsonNull()) && !jsonObj.get("imagePullPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `imagePullPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("imagePullPolicy").toString()));
      }
      if (jsonObj.get("imagePullSecrets") != null && !jsonObj.get("imagePullSecrets").isJsonNull()) {
        JsonArray jsonArrayimagePullSecrets = jsonObj.getAsJsonArray("imagePullSecrets");
        if (jsonArrayimagePullSecrets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("imagePullSecrets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `imagePullSecrets` to be an array in the JSON string but got `%s`", jsonObj.get("imagePullSecrets").toString()));
          }

          // validate the optional field `imagePullSecrets` (array)
          for (int i = 0; i < jsonArrayimagePullSecrets.size(); i++) {
            V1AlertmanagerSpecImagePullSecretsInner.validateJsonObject(jsonArrayimagePullSecrets.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("initContainers") != null && !jsonObj.get("initContainers").isJsonNull()) {
        JsonArray jsonArrayinitContainers = jsonObj.getAsJsonArray("initContainers");
        if (jsonArrayinitContainers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("initContainers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `initContainers` to be an array in the JSON string but got `%s`", jsonObj.get("initContainers").toString()));
          }

          // validate the optional field `initContainers` (array)
          for (int i = 0; i < jsonArrayinitContainers.size(); i++) {
            V1AlertmanagerSpecContainersInner.validateJsonObject(jsonArrayinitContainers.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("logFormat") != null && !jsonObj.get("logFormat").isJsonNull()) && !jsonObj.get("logFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logFormat").toString()));
      }
      if ((jsonObj.get("logLevel") != null && !jsonObj.get("logLevel").isJsonNull()) && !jsonObj.get("logLevel").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logLevel` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logLevel").toString()));
      }
      // validate the optional field `podMetadata`
      if (jsonObj.get("podMetadata") != null && !jsonObj.get("podMetadata").isJsonNull()) {
        V1AlertmanagerSpecPodMetadata.validateJsonObject(jsonObj.getAsJsonObject("podMetadata"));
      }
      if ((jsonObj.get("portName") != null && !jsonObj.get("portName").isJsonNull()) && !jsonObj.get("portName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `portName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("portName").toString()));
      }
      if ((jsonObj.get("priorityClassName") != null && !jsonObj.get("priorityClassName").isJsonNull()) && !jsonObj.get("priorityClassName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priorityClassName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priorityClassName").toString()));
      }
      // validate the optional field `resources`
      if (jsonObj.get("resources") != null && !jsonObj.get("resources").isJsonNull()) {
        V1AlertmanagerSpecResources.validateJsonObject(jsonObj.getAsJsonObject("resources"));
      }
      if ((jsonObj.get("retention") != null && !jsonObj.get("retention").isJsonNull()) && !jsonObj.get("retention").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `retention` to be a primitive type in the JSON string but got `%s`", jsonObj.get("retention").toString()));
      }
      if ((jsonObj.get("routePrefix") != null && !jsonObj.get("routePrefix").isJsonNull()) && !jsonObj.get("routePrefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `routePrefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("routePrefix").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("secrets") != null && !jsonObj.get("secrets").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `secrets` to be an array in the JSON string but got `%s`", jsonObj.get("secrets").toString()));
      }
      // validate the optional field `securityContext`
      if (jsonObj.get("securityContext") != null && !jsonObj.get("securityContext").isJsonNull()) {
        V1AlertmanagerSpecSecurityContext.validateJsonObject(jsonObj.getAsJsonObject("securityContext"));
      }
      if ((jsonObj.get("serviceAccountName") != null && !jsonObj.get("serviceAccountName").isJsonNull()) && !jsonObj.get("serviceAccountName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountName").toString()));
      }
      if ((jsonObj.get("sha") != null && !jsonObj.get("sha").isJsonNull()) && !jsonObj.get("sha").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sha` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sha").toString()));
      }
      // validate the optional field `storage`
      if (jsonObj.get("storage") != null && !jsonObj.get("storage").isJsonNull()) {
        V1AlertmanagerSpecStorage.validateJsonObject(jsonObj.getAsJsonObject("storage"));
      }
      if ((jsonObj.get("tag") != null && !jsonObj.get("tag").isJsonNull()) && !jsonObj.get("tag").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tag` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tag").toString()));
      }
      if (jsonObj.get("tolerations") != null && !jsonObj.get("tolerations").isJsonNull()) {
        JsonArray jsonArraytolerations = jsonObj.getAsJsonArray("tolerations");
        if (jsonArraytolerations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tolerations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tolerations` to be an array in the JSON string but got `%s`", jsonObj.get("tolerations").toString()));
          }

          // validate the optional field `tolerations` (array)
          for (int i = 0; i < jsonArraytolerations.size(); i++) {
            V1AlertmanagerSpecTolerationsInner.validateJsonObject(jsonArraytolerations.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("topologySpreadConstraints") != null && !jsonObj.get("topologySpreadConstraints").isJsonNull()) {
        JsonArray jsonArraytopologySpreadConstraints = jsonObj.getAsJsonArray("topologySpreadConstraints");
        if (jsonArraytopologySpreadConstraints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("topologySpreadConstraints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `topologySpreadConstraints` to be an array in the JSON string but got `%s`", jsonObj.get("topologySpreadConstraints").toString()));
          }

          // validate the optional field `topologySpreadConstraints` (array)
          for (int i = 0; i < jsonArraytopologySpreadConstraints.size(); i++) {
            V1AlertmanagerSpecTopologySpreadConstraintsInner.validateJsonObject(jsonArraytopologySpreadConstraints.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if (jsonObj.get("volumeMounts") != null && !jsonObj.get("volumeMounts").isJsonNull()) {
        JsonArray jsonArrayvolumeMounts = jsonObj.getAsJsonArray("volumeMounts");
        if (jsonArrayvolumeMounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumeMounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumeMounts` to be an array in the JSON string but got `%s`", jsonObj.get("volumeMounts").toString()));
          }

          // validate the optional field `volumeMounts` (array)
          for (int i = 0; i < jsonArrayvolumeMounts.size(); i++) {
            V1AlertmanagerSpecContainersInnerVolumeMountsInner.validateJsonObject(jsonArrayvolumeMounts.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("volumes") != null && !jsonObj.get("volumes").isJsonNull()) {
        JsonArray jsonArrayvolumes = jsonObj.getAsJsonArray("volumes");
        if (jsonArrayvolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumes` to be an array in the JSON string but got `%s`", jsonObj.get("volumes").toString()));
          }

          // validate the optional field `volumes` (array)
          for (int i = 0; i < jsonArrayvolumes.size(); i++) {
            V1AlertmanagerSpecVolumesInner.validateJsonObject(jsonArrayvolumes.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `web`
      if (jsonObj.get("web") != null && !jsonObj.get("web").isJsonNull()) {
        V1AlertmanagerSpecWeb.validateJsonObject(jsonObj.getAsJsonObject("web"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1AlertmanagerSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1AlertmanagerSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1AlertmanagerSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1AlertmanagerSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<V1AlertmanagerSpec>() {
           @Override
           public void write(JsonWriter out, V1AlertmanagerSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1AlertmanagerSpec read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1AlertmanagerSpec given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1AlertmanagerSpec
  * @throws IOException if the JSON string is invalid with respect to V1AlertmanagerSpec
  */
  public static V1AlertmanagerSpec fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1AlertmanagerSpec.class);
  }

 /**
  * Convert an instance of V1AlertmanagerSpec to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

